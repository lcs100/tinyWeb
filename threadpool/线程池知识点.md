# 线程池

## 服务器编程基本框架
主要由IO单元，逻辑单元和网络存储单元组成，每个单元通过请求队列进行通信，从而完成任务  
IO单元用于处理客户端连接，读写网络数据；逻辑单元用于处理业务逻辑的线程；网络存储单元指本地数据库和文件  

## 五种IO模型
阻塞IO：调用者调用了某个函数，等待该函数返回，不停去检查这个函数是否有返回，必须等待这个函数返回才可以进行下一步  

非阻塞IO：非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞IO执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1。  

信号驱动IO：linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO信号，处理IO事件。  

IO复用:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数  

异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。  

attention：阻塞I/O，非阻塞I/O，信号驱动I/O和I/O复用都是同步I/O。同步I/O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I/O操作，异步I/O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I/O操作。  

## 事务处理模式
1、reactor模式，主线程（IO处理单元）只负责监听文件描述符上是否存在事件发生，有的话立即通知工作线程（逻辑单元），读写数据和接受新数据以及处理客户请求均在工作线程中完成。通常由同步IO实现  
2、proactor模式，主线程和内核负责处理读写数据、接受新连接等IO操作，工作线程仅负责业务逻辑，比如处理请求。通常由异步IO实现  

## 同步IO模拟proactor模式
同步I/O模型的工作流程如下（epoll_wait为例）：  
主线程往epoll内核事件表注册socket上的读就绪事件。  
主线程调用epoll_wait等待socket上有数据可读。  
当socket上有数据可读，epoll_wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。  
睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。
主线程调用epoll_wait等待socket可写。  
当socket上有数据可写，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。  

## 并发编程模式
并发编程方法的实现有多线程和多进程两种，但这里涉及的并发模式指I/O处理单元与逻辑单元的协同完成任务的方法。  
半同步/半异步模式  
领导者/追随者模式  

## 半同步/半反应堆
半同步/半反应堆并发模式是半同步/半异步的变体，将半异步具体化为某种事件处理模式。  
半同步/半反应堆工作流程（以Proactor模式为例）  
主线程充当异步线程，负责监听所有socket上的事件  
若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件  
如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中  
所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权  

## 线程池
空间换时间，浪费服务器的硬件资源，换取运行效率。  
池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源。  
当服务器进入正式运行阶段，开始处理客户请求的时候,如果它需要相关的资源，可以直接从池中获取，无需动态分配。  
当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。  